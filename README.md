# Инициация

<a name="1"></a>

- [1](#1) Создать README.md.

  - У каждого проекта, размещенного на github, должно быть readme.md.

  - Readme должно содержать название проекта.

  - Readme должно содержать всю необходимую информацию для развертывания (установки) проекта и запуска/тестирования, обязательно самим протестировать с нуля разворачивание в новой папке.

  - В проекте должно быть использовано по минимуму глобальных библиотек, все они должны быть перечислены в Readme (webpack, karma и все, что может быть поставлено через npm, точно не должно быть глобальным)

  - Если из названия проекта не ясно его предназначение, то стоит внести его краткое описание.

  - Если в проекте используются нестандартные библиотеки или архитектурные подходы, то их тоже нужно указывать. Причем желательно указывать ссылки на их репозитории, чтобы человеку поставленному на этот проект, но не работавшему с используемыми технологиями, не нужно было искать их в гугле.

  - Если проект из репозитория уже где-то развернут (например, на github pages), то следует указать на него ссылку.

<a name="2"></a>

- [2](#2) Отступы делать пробелами, на проекте во всех файлах html, pug, etc должен быть одинаковый отступ — либо 4, либо 2 пробела.

<a name="3"></a>

- [3](#3) Спросить на входе, под какие браузеры верстаем (обязательно).

<a name="4"></a>

- [4](#4) Спросить, есть ли адаптив, если нет — то под какие разрешения верстать и что делать для других экранов.

<a name="5"></a>

- [5](#5) Запускать сайт через http://localhost, а не через file:///c:\test.html

  Иначе могут быть проблемы с элементами, вставляемыми через iframe (например, лайки от фб, вк и т. д.), и при работе скриптов, которые отправляют HTTP-запросы, плюс еще могут быть вообще неожиданные и неизвестные нам проблемы.

<a name="6"></a>

- [7](#6) Всегда помните: если вы можете решить проблемы каким-то способом, это не значит, что способ действительно стоит применять.

  И в верстке, и в программировании часто возникают ситуации, когда можно написать вполне рабочий код, но сделать это ненадежным способом, либо используя откровенные хаки, неочевидные другим разработчикам, либо просто оформив все некрасивым способом. Если перед вами появилась проблема, то нужно не только решить ее, но и сделать решение читабельным, масштабируемым и надежным. Во всех случаях, когда появляются сомнения, лучше спросить более опытных товарищей - это и вам позволит быстрее вырасти, и проекту получить более качественный код.
  
 # HTML

1. [Семантика](#1)
2. [Теги](#2)
3. [Подключаемые файлы](#3)

<a name="1"></a>

## Семантика

<a name="1.1"></a>

- [1.1](#1.1) Объединять блоки не по их визуальному расположению, а по их смыслу.

<a name="1.2"></a>

- [1.2](#1.2) Если есть что-то похожее на список, проверяем, как будет выглядеть при большем количестве элементов.

<a name="1.3"></a>

- [1.3](#1.3) Все элементы с текстом, контент которых формируется динамически, проверяем на то, чтобы они не ломались при большем количестве текста, чем на макете.

<a name="1.4"></a>

- [1.4](#1.4) Проверять страницы на наличие ошибок

  Часто встречающиеся ошибки:

  <a name="1.4.1"></a>

  - [1.4.1](#1.4.1) Вставка блочных элементов внутрь инлайновых.

    Никаких `<span><div></div></span>`.

  <a name="1.4.2"></a>

  - [1.4.2](#1.4.2) Не предназначенные для расширения другими файлами через какой-нибудь шаблонизатор .html файлы страниц начинаются не с `<!DOCTYPE html>`, что противоречит HTML5 стандарту.

  <a name="1.4.3"></a>

  - [1.4.3](#1.4.3) Используются самозакрывающиеся теги, если они поддерживают другой режим.

    Нельзя:

    ```html
    <div />
    <span />
    ```

    Можно:

    ```html
    <link />
    <img />
    <input />
    ```

  <a name="1.4.4"></a>

  - [1.4.4](#1.4.4) Не все изображения `<img>` содержат `alt` атрибут.

  <a name="1.4.5"></a>

  - [1.4.5](#1.4.5) Есть вложенные формы `<form>`.

  Полный список потенциальных ошибок описан [тут](https://validator.w3.org/docs/errors.html).

<a name="1.5"></a>

- [1.5](#1.5) Использовать h1..h6 только для заголовков, причем h1 должен встречаться в одной странице всего один раз.

<a name="1.6"></a>

- [1.6](#1.6) Использовать `<table>` только для реальных таблиц.

  Если перед таблицей есть её текстовое описание, сделать это внутри тега `<table>` через `<caption>`.  
  Если у таблицы первая строка идет заголовком, то использовать `<thead>` и вложенные `<th>` для этого и использовать "scope" для этих ячеек.

  Пример:

  ```html
  <table>
    <caption>
      First two U.S. presidents
    </caption>
    <thead>
      <tr>
        <th scope="col">Name</th>
        <th scope="col">Took office</th>
        <th scope="col">Party</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>George Washington</td>
        <td>April 30, 1789</td>
        <td>n/a</td>
      </tr>
      <tr>
        <td>John Adams</td>
        <td>March 4, 1797</td>
        <td>Federalist</td>
      </tr>
    </tbody>
  </table>
  ```

<a name="1.7"></a>

- [1.7](#1.7) Не использовать `<br>` нигде, кроме случаев, когда соблюдены все требования:

  - Newlines are semantically meaningful.
  - Indentation is not semantically meaningful (otherwise you should use a `<pre>`).
  - There exists no other semantically appropriate tag, like a paragraph or header tag.

<a name="1.8"></a>

- [1.8](#1.8) Использовать семантические теги.

  Почему их нужно использовать, узнать можно [здесь](https://www.youtube.com/watch?v=bDYEnNzprzE) и [здесь](https://developer.mozilla.org/ru/docs/Learn/%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%BE%D1%81%D1%82%D1%8C/HTML).  
  [Блок-схема](http://html5doctor.com/downloads/h5d-sectioning-flowchart.pdf) для выбора семантических тегов.

<a name="2"></a>

## Теги

<a name="2.1"></a>

- [2.1](#2.1) Все теги должны работать даже без CSS и JS.

  Все тексты, видимые сначала при открытии страницы так же должны быть доступны, формы должны сабмититься, ссылки должны переходить (а ссылки, по которым вообще не должно быть перехода и для которых принято ставить `href="#"`, вообще не использовать, это будет далее).

<a name="2.2"></a>

- [2.2](#2.2) Структура тегов в первую очередь должна идти от содержания, а не от дизайна

  ![пример](http://image.prntscr.com/image/a89c1aed00f14864851989caceacd59d.png) — например, такой элемент можно оформить как четыре идущих подряд элемента: иконка сообщений, бадж с цифрой 10, иконка аватара и имя пользователя. Но тут надо явно объединить с помощью `<div>` два блока, чтобы семантически они были отдельными — блок с информацией по сообщению и блок про пользователя. Для css потом, возможно, придется писать лишние стили, но верстка будет более осмысленной и не привязанной лишний раз к дизайну.

<a name="2.3"></a>

- [2.3](#2.3) Перед `<!DOCTYPE html>` не должно быть никаких символов, включая пробелы и переносы строк.

<a name="2.4"></a>

- [2.4](#2.4) Внутри `<head>` первым тегом должно идти `<meta charset="utf-8">`.

<a name="2.5"></a>

- [2.5](#2.5) У каждой страницы должны быть теги `title` и мета теги `keywords`, `description` (на содержимое спросить контент у менеджера).

<a name="2.6"></a>

- [2.6](#2.6) В `head` добавлять `<meta name="viewport" content="initial-scale=1.0, width=device-width">` — на мобильных браузерах можно избежать горизонтального скролла и масштабировать контент на всю ширину экрана.

<a name="2.7"></a>

- [2.7](#2.7) Все атрибуты должны быть внутри двойных кавычек

  Нельзя:

  ```html
  <img width=200 />
  <div class=block>
    <a href='/some/url'></a>
  </div>
  ```

  Можно:

  ```html
  <img width="200" />
  <div class="block">
    <a href="/some/url"></a>
  </div>
  ```

  Плюс, если в проекте нет других соглашений, атрибуты должны именоваться lower-case-hyphenated (имена только маленькими буквами и через дефис) и, если значение строковое и показывает какое-то имя, то тоже должно быть lower-case-hyphenated. Кастомные атрибуты стараться начинать с data- (это стандартная практика, рекомендованная для HTML5).

  Пример: `<a href="/" data-index="33" data-page-name="main-page">Home</a>`

<a name="2.8"></a>

- [2.8](#2.8) Не использовать id, кроме случаев, когда они семантически востребованы.

  Когда гарантируется их уникальность, например, на уровне базы данных и когда вам нужно:

  - сделать рабочую навигацию в рамках одной страницы (например, как на Википедии или на этом сайте сборника [best-practices](https://isobar-idev.github.io/code-standards/#javascript_javascript).
  - связать `<label>` и `<input />`, которые находятся в совершенно разных ветках дерева DOM (вообще, лучше всегда просто `<input />` внутрь `<label>` ставить, и тогда никакие айдишники не нужны).

<a name="2.9"></a>

- [2.9](#2.9) Все теги идут только с классами — никаких пустых `<div>`, `<section>` и т. д. Но можно для инлайновых элементов, если есть четкое понимание зачем. Это очень сильно мешает новым людям входить в проект и вам через некоторое время разобраться в собственной верстке.

<a name="2.10"></a>

- [2.10](#2.10) Избегать по максимуму инлайновые стили и обработчики событий в `html` (то есть никаких `<div onclick="func()">`).

<a name="2.11"></a>

- [2.11](#2.11) Не использовать ссылки с пустым или невалидным `href` (никаких `<a href="#">`) — тогда лучше использовать ссылку-заглушку на несуществующий урл, который явно говорит, что ссылка не проставлена.

  Если вы верстаете проект, в котором есть страницы, которых нет в дизайне (допустим, они потом при интеграции с сервером динамически создаваться будут), то лучше ставьте адрес, который явно говорит, что это ссылка-заглушка. Причем все ссылки-заглушки должны в рамках проекта иметь один адрес, например `<a href="/mock-address/change-me"></a>`.  
  Для SPA иногда приходится динамически js-ом генерить такие ссылки (как минимум в angular, там для этого даже отдельный атрибут ng-href), которые бы поддерживали динамическую генерацию на основе чистого клиентского раутинга.  
  Не надо никаких `<a href="#">` или `<a href="javascript:someFunc(1)">`. Плюс не надо сюда сохранять урлы до методов API на сервере, надеясь, что JS-ом вы сможете потом обработать клик, отправить ajax запрос на сервер по этому урлу и сами обработать ответ. Этого не произойдет, если юзер откроет ссылку в новой вкладке через контекстное меню или клик колесом мыши, например. Все урлы, указанные в `href`, должны открывать читаемый для человека контент, который целиком зависит только от сервера. [Оригинал последнего абзаца](https://isobar-idev.github.io/code-standards/#html_anchors_amp_links).

<a name="2.12"></a>

- [2.12](#2.12) Ссылки на чужие сайты должны содержать атрибут `target="_blank"`, чтобы открываться в новом окне.

<a name="2.13"></a>

- [2.13](#2.13) Все ссылки с `target="_blank"` должны так же содержать атрибут `rel="noopener noreferrer"`.

  Это связано с [уязвимостью](https://mathiasbynens.github.io/rel-noopener/), в соответствии с которой сайт, который вы открыли, получит доступ к сайту, с которого перешли через `window.opener`, причем это работает даже кроссдоменно.

<a name="2.14"></a>

- [2.14](#2.14) Все инпуты, селекты и другие интерактивные элементы форм должны располагаться внутри тега `<form>`.

  ```html
  <form>
    <label>
      First name:
      <input type="text" name="first-name" value="John" />
    </label>
    <label>
      Last name:
      <input type="text" name="last-name" value="Doe" />
    </label>
    <button type="submit">Submit</button>
  </form>
  ```

<a name="2.15"></a>

- [2.15](#2.15) Все интерактивные элементы, для которых дизайнером задуман нетривиальный порядок полей, должны иметь атрибут `tabindex`, плюс всегда кнопка сабмита в tabindex должна быть последней (соответственно, если есть визуально поля под кнопкой, у них должен быть tabindex и он должен быть меньше, чем у кнопки).

<a name="2.16"></a>

- [2.16](#2.16) Спрашивать у дизайнеров, какие элементы делать autofocus на какой странице.

<a name="2.17"></a>

- [2.17](#2.17) Если у поля есть четкое назначение, то использовать соответствующий тип (email, number, color и т. д.).

<a name="2.18"></a>

- [2.18](#2.18) Каждый тег, в котором может лежать текст, должен быть проверен на большое количество символов.

  Все заголовки и все теги с текстовыми описаниями.  
  Все инпуты проверять, чтобы при заполнении текст не прижимался вплотную к правой границе:  
  ![image](https://user-images.githubusercontent.com/12808495/55307777-c0e18e80-5482-11e9-927f-9c195d81555e.png)

<a name="2.19"></a>

- [2.19](#2.19) Классические инлайн теги должны быть только inline или inline-block, и в них не должно быть ничего, кроме простого текста и других таких же инлайновых тегов.

  Исключения: `<a>` — иногда ссылку надо сделать блочным элементом, но лучше использовать inline-block.

<a name="2.20"></a>

- [2.20](#2.20) Для телефонов, емайл-адресов и скайп никнеймов нужно использовать `<a>` c соответствующим адресом.

  ```html
  <a href="tel: +74951234567">+7 (495) 123-45-67</a>
  <a href="mailto: example@mail.ru">example@mail.ru</a>
  <a href="skype: someskype?call">someskype</a>
  ```

<a name="2.21"></a>

- [2.21](#2.21) Отображать примеры кода через тег `<code>`.

  Иногда на некоторых проектах нужно прямо на сайте показывать пользователям примеры кода (например, [здесь в туториале Реакта](https://reactjs.org/) целая куча примеров кода) — эти примеры должны быть написаны моноширинными шрифтами и отличаться от обычного текста — по умолчанию достаточно обрамить код в тeг `<code>`.

<a name="3"></a>

## Подключаемые файлы

<a name="3.1"></a>

- [3.1](#3.1) Все картинки, шрифты и т. д. должны иметь уникальное название в рамках проекта и не содержать кириллических символов. Если в проекте нет индивидуальных соглашений, то они должны именоваться в стиле lower-case-hyphenated.

<a name="3.2"></a>

- [3.2](#3.2) В проекте обязательно должен быть favicon.ico, подключаемый на всех страницах.

  Как это сделать, используя webpack, очень хорошо написано в [этой статье](https://medium.com/tech-angels-publications/bundle-your-favicons-with-webpack-b69d834b2f53).

<a name="3.3"></a>

- [3.3](#3.3) В сафари своя версия favicon, ее тоже обязательно надо настраивать.

  То есть нужна svg для контура иконки, и нужен цвет для иконки при наведении. [Статья](https://yoast.com/dev-blog/safari-pinned-tab-icon-mask-icon/).

<a name="3.4"></a>

- [3.4](#3.4) Прогонять картинки через [kraken.io](https://kraken.io/) или использовать свои CLI-утилиты для этого.

<a name="3.5"></a>

- [3.5](#3.5) Все фотографии и картинки, где нет прозрачности, делать в jpg.

<a name="3.6"></a>

- [3.6](#3.6) При нарезке картинок из фотошопа поставить DPI равным 72dpi, а саму картинку сохранить через "Save for Web".

<a name="3.7"></a>

- [3.7](#3.7) Максимальная ширина картинки — 1920 пикселей. Если в макетах она больше, пропорционально ужимайте.

  На самом деле, это правило спорно (как минимум для ретина дисплеев я не уверен), но следуйте ему, пока дизайнер не скажет другого.

# CSS

1. [Общие требования](#1)
2. [Правила](#2)
3. [Шрифты](#3)
4. [БЭМ](#4)
5. [Возможные ошибки](#5)

<a name="1"></a>

## Общие требования

<a name="1.1"></a>

- [1.1](#1.1) Главное! Используем [pixel-perfect](https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru), если заказчик предоставил макет.

<a name="1.2"></a>

- [1.2](#1.2) Не подключать стили с удаленных источников — только с наших серверов.

<a name="1.3"></a>

- [1.3](#1.3) CSS — опасная сила.

  Все стили, подключаемые к странице, являются глобальными, и, если этим злоупотреблять, то можно легко довести проект до состояния крайне болезненного внедрения любого нового элемента или изменения старого. Это чаще всего происходит, когда создаются "общие" классы, потом крепятся к разным элементам на странице (банальный пример — шапка, у которой внутри форма поиска, которая есть на всех страницах с одинаковыми классами) и в итоге, когда по дизайну на разных страницах появляются небольшие отличия в шапке, плодятся классы, переписывающие свойства. И так почти для всех элементов каждой страницы. В итоге, меняя крайнюю правую ссылку в сайдбаре на странице новостей, вы можете поломать верстку всего сайдбара на какой-нибудь другой странице, например, на странице личного кабинета.

  Для того чтобы такого не происходило, существуют разные методологии, например, `БЭМ` (прочитать про него обязательно хотя бы в общих чертах) или, например, [rscss](https://rscss.io/index.html). Для начала можете изучить [небольшой подход](https://isobar-us.github.io/code-standards/), который используют ребята из `Isobar` — он описан в рамках их стандарта и состоит из 7 небольших абзацев.

<a name="1.4"></a>

- [1.4](#1.4) Отступы делать пробелами, один уровень — 2 пробела.

<a name="1.5"></a>

- [1.5](#1.5) Использовать одинарные кавычки.

<a name="1.6"></a>

- [1.6](#1.6) Перед началом работы обязательно четко знать все приоритеты селекторов и все 4 вида возможных отношений.

  Отношения элементов между собой могут быть:

  - `div p` – элементы p, являющиеся потомками div
  - `div > p` – только непосредственные потомки
  - `div ~ p` – правые соседи: все p на том же уровне вложенности, которые идут после div
  - `div + p` – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div (если есть)

  А про приоритеты можно почитать [здесь](https://habrahabr.ru/post/137588/) и во многих других местах.

<a name="1.7"></a>

- [1.7](#1.7) Не использовать `@import` внутри файлов.

  Имеется в виду, что в конечном `css` файле, который получает клиент, не должно быть этих конструкций. Но если настроен `WebPack` и `css-loader`, который как раз этот случай обрабатывает, либо используются компилируемые аналоги, которые умеют вместо импортов подставлять непосредственное содержимое файлов, то импорты возможны, так как браузер все равно их не увидит и не получит никогда в реальной работе.

  Можно выделить пару причин, почему не стоит использовать `@import`:

  - Некоторые старые браузеры не поддерживают использование правила `@import`, и стили, которые мы подгружаем через это правило, будут потеряны
  - `@import` блокирует параллельную загрузку стилей, а это означает, что браузер будет ожидать завершения загрузки импортированного файла, прежде чем начнёт обрабатывать остальную часть содержимого.
  - Более подробно можно почитать [здесь](http://www.stevesouders.com/blog/2009/04/09/dont-use-import/).

<a name="1.8"></a>

- [1.8](#1.8) Все правила должны быть разбиты на разные файлы по страницам и блокам, каждый файл должен быть не длиннее, чем 1000 строк.

<a name="1.9"></a>

- [1.9](#1.9) Каждое CSS-правило должно быть на отдельной строке.

  Это очень поможет как минимум при просмотре diff-ов в системе контроля версий. Плюс это позволит избежать горизонтальной прокрутки.

<a name="1.10"></a>

- [1.10](#1.10) Для всех интерактивных элементов (ссылки, кнопки, дропдауны, инпуты, селекты) дизайнер может прорисовать отдельные состояния и спрятать в ближайшем слое — всегда проверять для каждого элемента, есть ли отрисованное состояние.

<a name="1.11"></a>

- [1.11](#1.11) Дизайнеры могут ошибаться — иногда надо делать запросы на изменение макета, если они нарисовали что-то переусложненное.

  Например, в макете может быть отцентрированная по вертикали относительно текста полоска:

  | ![Пример](https://user-images.githubusercontent.com/12808495/55335190-df687980-54c4-11e9-8623-13ecdb996ebc.png) |
  | :-------------------------------------------------------------------------------------------------------------: |
  |                       _эта картинка просто пример, не факт, что тут как раз такая ошибка_                       |

  Дизайнер может просто на глаз положить эту полоску на среднем уровне нижних букв текста, однако вы как верстальщики просто примените vertical-align: middle и увидите, что полоска выше/ниже уровня, который показал дизайн, и Pixel Perfect явно это подсвечивает. Чаще всего не надо хардкодить какой-нибудь неочевидный отступ, просто чтобы идеально соответствовать макету — лучше сказать дизайнеру, что автоматом полоска ставится на другое место и её лучше там и оставить. А дизайнеру подучить типографику.

<a name="1.12"></a>

- [1.12](#1.12) Пытаться по максимуму делать сайт резиновым (ставьте ширину в процентах и выставляйте max-width, min-width) — прибегайте к фиксированной ширине элемента, только если по макету от этого никак не уйти.

  Если все-таки сайт должен быть с фиксированный шириной, обязательно проверяйте правую сторону каждой страницы на маленьких экранах. Очень частая ошибка новичков не все элементы делать с min-width, и при горизонтально прокрутке получается такая штука:

  ![image](https://rizzoma.com/r/files/a87a0a28b84d6326d4f3909e8801dab7-60dd9b15a5f2c5e495726e74545edcae-0-0.7016728184648524)

<a name="1.13"></a>

- [1.13](#1.13) При сборке проекта при отсутствии дизайна (на CSS-фреймворках, например) избегать "лепки".

  Если вы разрабатываете проект, у которого нет дизайна (при помощи CSS-фреймворков, например), то старайтесь избегать лепки.

  Правила те же, что и при написании программных модулей: старайтесь придать пространства между компонентами, ограничить их друг от друга визуально (осуществляется слабое зацепление), но вместе с этим, сами компоненты должны выглядеть самодостаточно, т.е. обладать всем необходимым, но без избыточности, функционалом, чтобы это можно было назвать полноценной компонентой (осуществляется сильная связанность).

  Хорошим детектором является тут БЭМ: старайтесь делать отступы между блоками минимум в два раза больше, чем внутри блока между элементами.

<a name="1.14"></a>

- [1.14](#1.14) Все стили одного блока должны быть в одном месте и отсортированы по порядку их расположения на странице.

  То есть, если есть шапка, а внутри нее поисковая форма, то в .css файлах нельзя сначала определить стили шапки, потом кучу стилей тела страницы и потом стили поисковой формы шапки. Должны идти стили самой шапки и сразу под ней стили формы.

  При этом стили сайдбара не могут идти раньше стилей шапки, а стили футера идти раньше стилей сайдбара. Лучше вообще эти стили разнести по разным файлам.

<a name="1.15"></a>

- [1.15](#1.15) Футер страницы должен быть всегда прижат к низу страницы, даже если на странице мало контента ([5 методов, как сделать это](http://dimox.name/press_footer_bottom_with_css/)).

<a name="1.16"></a>

- [1.16](#1.16) Имена.

  Использовать `lower-case-hyphenated` (то есть не `mySuperAwesomeElement` и не `my_super_awesome_element`)

  Имена должны отражать смысл, а не описание стилей (`"loading"`, а не `"big-yellow-spinny-thing"`)

<a name="2"></a>

## Правила

<a name="2.1"></a>

- [2.1](#2.1) Не использовать `!important`.

  В 99% случаях проблему можно решить, грамотно используя `БЭМ` или `CSS modules`. В сложных редких случаях лучше увеличивать приоритет селекторов (например, когда надо стили библиотеки переопределить).

<a name="2.2"></a>

- [2.2](#2.2) Не использовать `position: absolute` для стилизации, где это можно заменить другими подходами.

<a name="2.3"></a>

- [2.3](#2.3) Не двигать элемент при помощи `top`, `left`, `right` или `bottom` при `position: relative`, где это можно заменить другими подходами.

  Можно использовать сам `position: relative` (без свойств `top`, `left`, `right` или `bottom`) для `z-index` и для того, чтобы указать потомкам элемента ориентир.

<a name="2.4"></a>

- [2.4](#2.4) Не использовать отрицательные margin.

  На самом деле, отрицательные `margin` — это валидные правила, они поддерживаются спецификацией `CSS`, и их даже используют такие гиганты, как Bootstrap (посмотрите стили для `.row`).

  Но это очень неочевидные правила, их тяжело обнаружить, и их почти всегда можно заменить более легкими и предсказуемыми свойствами.

<a name="2.5"></a>

- [2.5](#2.5) Избегать фиксирования высоты.

  Почти всегда использование фиксированного в пикселях, процентах и других единицах `height` является признаком неправильного кода. Это делает очень неочевидным поведение элементов, которые следуют за зафиксированным по высоте, может произойти обрезание контента или его наложение на следующие элементы.

  Когда это все-таки может быть нужно:

  - У элемента надо ручками подстроиться под высоту потомков, которых "убрали" из общего потока. "Убрать" из потока можно через `position: absolute`, например. Это может быть слайдер, у которого потомки крутятся как раз через позиционирование, а не смещение `margin`-ом

  - По дизайну надо подстроить все элементы под определенную высоту, а контент, вылезающий за пределы, обрезать.

<a name="2.6"></a>

- [2.6](#2.6) Избегать фиксированных выравниваний.

  Если блок должен быть отцентрирован (хоть по горизонтали, хоть по вертикали), то центрировать его динамически, а не фиксированным `margin-top`.

  Например:

  ![Пример](https://user-images.githubusercontent.com/12808495/55335190-df687980-54c4-11e9-8623-13ecdb996ebc.png)

  Здесь картинку, текст и полоску надо центрировать через `vertical-align`, а не `top: 55px` у полоски.

  Часто будут попадаться случаи более сложного центрирования — почти для каждого есть свой метод, надо их отдельно изучать.

  [Статья про vertical-align](http://web-standards.ru/articles/vertical-align/)

  Что нужно сделать, чтобы центрировать по высоте _элемент1_ внутри _элемента2_:

  - Оба элемента должны быть любыми inline элементами

  - У _элемента2_ должен быть указан font-size или line-height. _Элемент2_ отцентрируется только в зависимости от font-size или line-height и не обратит внимания на height.

<a name="2.7"></a>

- [2.7](#2.7) Прописывать дефолтный цвет фона, цвет шрифта, `font-size` и семейство шрифта у `html`.

  Далее размер шрифта будет ориентиром для всех элементов, у которых используется rem для единиц измерения кегля.

<a name="2.8"></a>

- [2.8](#2.8) При тестировании обязательно посмотреть цвет `:visited` ссылки.

  Браузер по умолчанию такие ссылки фиолетовыми делает, что чаще всего недопустимо в дизайне.

<a name="2.9"></a>

- [2.9](#2.9) Добавлять элементу `cursor: pointer`, если он кликабелен и по умолчанию этого не поддерживает.

<a name="2.10"></a>

- [2.10](#2.10) Удалять все неиспользуемые правила и правила, которые никак не влияют на отображение (например, дублирующие свойства по умолчанию или нулевые `margin`, если они и так не выставлены) — они могут в дальнейшем при правках внести неочевидное поведение и из-за них тяжело разбираться в проекте.

<a name="2.11"></a>

- [2.11](#2.11) Слова, целиком состоящие из верхнего регистра, предпочтительно делать через стиль `text-transform: uppercase`, а не реальным вводом текста заглавными буквами.

<a name="2.12"></a>

- [2.12](#2.12) При установке элементу `outline: none` обязательно выставить стили для `:focus` этому элементу.

  `outline` очень полезен, когда юзер заполняет форму, используя клавишу `tab` для переключения между инпутами и кнопками. Если `outline` убрать, станет менее заметно (или незаметно вовсе для кнопок), какой элемент сейчас выбран.

<a name="2.13"></a>

- [2.13](#2.13) Все использования `@media` должны идти сразу после основных правил элемента, для того чтобы можно было увидеть все правила и все возможные состояния элемента в одном экране без прокручивания.

<a name="2.14"></a>

- [2.14](#2.14) Вендорные префиксы должны идти перед общим стилем.

  Стандартное правило всегда должно быть под специфичными правилами для каждого движка.

  Пример:

  ```css
  .thing {
    -webkit-transition: all 100ms;
    -moz-transition: all 100ms;
    -o-transition: all 100ms;
    transition: all 100ms;
  }
  ```

<a name="3"></a>

## Шрифты

<a name="3.1"></a>

- [3.1](#3.1) Если клиент предоставил макеты с кастомными шрифтами, проверить, свободные ли они и, если нет, то запросить купленные файлы шрифтов.

<a name="3.2"></a>

- [3.2](#3.2) Если не требуется поддержка старых браузеров, шрифты должны быть в форматах `.woff2`, `.woff`. Сначала подключать `.woff2` шрифты, затем — `.woff` (пример ниже).

<a name="3.3"></a>

- [3.3](#3.3) Если в проекте должна быть поддержка нелатинских символов (например, русских), проверьте, что в файле шрифта эти символы есть.

<a name="3.4"></a>

- [3.4](#3.4) Разные начертания одного и того же шрифта подключайте под одним именем, но для разных `font-weight` и `font-style`.

  ```css
  @font-face {
    font-family: "Lato";
    src: url("../fonts/lato-regular.woff2"), url("../fonts/lato-regular.woff");
    font-weight: 400;
    font-style: normal;
  }
  @font-face {
    font-family: "Lato";
    src: url("../fonts/lato-italic.woff2"), url("../fonts/lato-italic.woff");
    font-weight: 400;
    font-style: italic;
  }
  @font-face {
    font-family: "Lato";
    src: url("../fonts/lato-light.woff2"), url("../fonts/lato-light.woff");
    font-weight: 300;
    font-style: normal;
  }
  @font-face {
    font-family: "Lato";
    src: url("../fonts/lato-lightitalic.woff2"),
      url("../fonts/lato-lightitalic.woff");
    font-weight: 300;
    font-style: italic;
  }
  ```

<a name="3.5"></a>

- [3.5](#3.5) Всегда использовать как минимум один запасной шрифт и одно запасное семейство.

  Их перечисляют через запятую в `font-family`, так что каждое использование `font-family` должно происходить по схеме:

  ```css
  block {
    font-family: Helvetica, Arial, sans-serif;
  }
  ```

  Здесь `Helvetica` — нестандартный подключаемый шрифт.

  `Arial` — стандартный шрифт, который используется почти на всех клиентах, он будет использоваться, если не удалось подключить `Helvetica`.

  `sans-serif` — это семейство всех шрифтов без засечек (каковыми являются и `Helvetica`, и `Arial`). Если даже `Arial-а` на компе нет, то поставится какой-то системный дефолтный шрифт без засечек. Выбор здесь надо делать из `"serif,"` `"sans-serif,"` или `"monospace"`. Для шрифтов без засечек использовать по умолчанию `Arial`, для шрифтов с засечками — `Georgia` (а не `Times New Roman`), а для моноширинных — `"Courier New"`

<a name="3.6"></a>

- [3.6](#3.6) Названия шрифтов, содержащие пробелы, цифры или знаки пунктуации, кроме дефисов, заключать в кавычки.

  Пример:

  ```css
  block {
    font-family: 'Times New Roman', serif;
  }
  ```

<a name="4"></a>

## БЭМ

<a name="4.1"></a>

- [4.1](#4.1) Именование БЭМ-сущностей должно следовать следующим ограничениям:

  Блок, элемент — всегда имя существительное (noun)

  Модификатор — должен удовлетворять свойствам [модификатора из английского языка](https://en.wikipedia.org/wiki/Grammatical_modifier). Всегда `adjective` или `adjectival phrase`.

  Таким образом, фразы на английском языке `"$BLOCK_NAME [is] $MODIFIER_NAME"`, `"$ELEMENT_NAME [is] $MODIFIER_NAME"` или `"$MODIFIER_NAME $BLOCK_NAME"`, `"$MODIFIER_NAME $ELEMENT_NAME"`, `"$ELEMENT_NAME WITH $MODIFIER_NAME $MODIFIER_KEY"` должны быть синтаксически корректными словосочетаниями.

  Примеры _корректных имён_:

  - `input_selected` — `selected input` — выделенный инпут или `input is selected` — инпут выделен
  - `header_size_large` — `header with large size` — заголовок с большим размером.

  Примеры _**НЕ**корректных имён_:

  - `form__`**_save_**`_small`, для элемента save (который, например, вешается на кнопку) — `small save` — маленький сохранить, `save small` — сохранить маленький. Правильно будет употребить noun вместо `verb` и переименовать элемент в **_`save-button;`_** `small save-button` — маленькая кнопка сохранения

  - `input_`**_focus_** — `input focus` — инпут сфокусировать или `input is focus` — инпут это фокус. Правильно будет употребить `adjective` вместо `noun/verb` и переименовать модификатор в `focused; input_`**_focused_** — `focused input` — сфокусированный инпут

  - `row_`**_error_** — `row error` — ошибка строки или `row is error` — строка это ошибка. Правильно будет употребить `adjectival phrase` вместо `noun` и переименовать модификатор в `with-error`. `row_`**_with_**`-error` — `row with error` — строка с ошибкой.

  Обоснование: мы сможем всегда однозначно и без лишних затрат энергии истолковать сущность элемента вёрстки и накладываемые на него свойства.

<a name="4.2"></a>

- [4.2](#4.2) Верстаем всегда по БЭМу, архитектура верстки должна быть компонентной.

  Каждый блок должен лежать в своей папке.

  Папки блоков нельзя вкладывать друг в друга.

<a name="4.3"></a>

- [4.3](#4.3) Каждый компонент — отдельный блок из методологии БЭМ.

<a name="4.4"></a>

- [4.4](#4.4) Каждый компонент должен иметь только явные зависимости, быть самодостаточным.

  Все зависимости делать явно, импортируя в начале компонента и вставляя в нужное место верстки.

  Самодостаточность говорит о том, что каждый компонент должен внутри себя содержать все необходимое — всю верстку, все стили и все js-скрипты.

  Ничего лишнего в компоненте быть не должно:

  - Не должно быть определения других блоков внутри этого блока
  - Не должно быть стилей, которые бы влияли на другие блоки любым способом
  - Не должно быть глобальных стилей (например, на все теги `span`)
  - Компонент не должен влиять на `DOM` другого компонента (менять верстку крайне запрещено)

<a name="4.5"></a>

- [4.5](#4.5) Кастомизировать компоненты только через модификаторы, никаких примесей.

  Почти в любом проекте возникает необходимость кастомизировать блоки. Например, есть вёрстка из 20 страниц. На 15 из этих страниц встречается хэдер, причём у 10 из них хэдер синего цвета, на трёх — серый, и на двух — прозрачный. Это значит, что компонент хэдер должен быть кастомизируемым, и осуществляются подобного рода кастомизации через добавление модификаторов к блоку, а не путём передачи отдельных классов со стилями.

  Предположим, что на фоне у промо страницы есть видео, и по дизайну нам нужно сделать прозрачный хэдер со светлым шрифтом (по умолчанию — тёмный).

  Плохо:

  ```pug
  .promo-page
    +header({ classname: 'promo-page__header' })
  ```

  Хорошо:

  ```pug
  .promo-page
    +header({ theme: 'transparent', font: 'light' })
  ```

  При правильном подходе, естественно, надо будет научиться принимать эти два параметра, добавлять самому модификаторы к нужным классам и в CSS компонента прописывать правила для этих модификаторов.

  Это правило внедрено после болезненного опыта поддержки проекта средней сложности, и вот какие шишки набиты с использованием примесей:

  - Нарушается инкапсуляции — использование внешних стилей внутри компоненты ведёт к проблемам в сопровождении в дальнейшем. Дело в том, что стили компоненты являются её составной частью и не должны влиять на то, что её окружает. Также справедливо обратное — внешние стили не должны влиять на компоненту. Иными словами, компонента должна быть самодостаточна. Прибегая к использованию внешних стилей, мы создаём зависимость между двумя стилями — внешним и внутренним. Каждому из стилей нужно знать, из чего состоит другой, чтобы глобальный стиль не поломал стиль компоненты. Это и есть нарушение инкапсуляции

  - Если компонента используется на 20 разных страницах, то после изменения одного свойства в самом компоненте придется пройти по всем 20 страницам вручную и проверить, что ничего не сломалось, потому что неизвестно, какие могут быть стили навешаны в местах использования через кастомные классы, и надо самому проверить все комбинации

  - Примесь обычно вешается только на верхний уровень компонента, но иногда надо кастомизировать что-нибудь внутреннее, тогда получается, надо уже две примеси передавать и принимать в компоненте, одна примесь — для свойств всего блока, вторая — для какого-то элемента, а когда понадобится еще другой элемент кастомизировать, придется добавить третью примесь :)

  - Не получится четко составить список всех возможных состояний компоненты, а при подходе с модификаторами мы явно видим все возможные параметры на входе, и когда их число будет зашкаливать, можем пнуть дизайнера, что он слишком расфантазировался и пора бы переходить к единому стайлгайду

<a name="4.6"></a>

- [4.6](#4.6) Для позиционирования блока в родительском контейнере тоже не надо использовать миксы — решается данная проблема путем добавления специальных контейнеров.

  Допустим, есть родительский блок, в нем — дочерний блок, который нам и необходимо спозиционировать. Для позиционирования внутреннего блока создаем в родительском элемент-обертку и просто задаем свойства (_margin, padding, position_ etc) этому контейнеру. Таким образом, позиционирование блока у нас находится в файле родительского блока и никак не влияет на стили самого блока.

  Данный способ позволяет, не используя миксы, спозиционировать дочерний блок.

  Например, в хэдере у нас находится обычная голубая кнопка, но именно тут, в шапке, она должна иметь отступ с левой стороны, для этого мы добавим `div.header__button`:

  ```pug
   div.header
     div.header__button
       +button({ color:blue })
  ```

  А в стили хэдера просто добавим:

  ```css
  .header__button {
    margin-left: 3rem;
  }
  ```

<a name="5"></a>

## Возможные ошибки

> В css есть несколько очень неочевидных правил, лучше изучить их на теории заранее, чем ломать голову часами, почему верстка едет

<a name="5.1"></a>

- [5.1](#5.1) Верхний margin первого элемента смещает за собой всех родителей вниз.

  Допустим, желаемый вид должен быть таким:

  ![image](https://user-images.githubusercontent.com/12808495/55340918-d92bca80-54cf-11e9-9701-eed499af7a05.png)

  Чтобы заголовок имел отступ от верхней границы, мы добавляем ему margin: 20px 0 0; однако получаем такое поведение:

  ![image](https://user-images.githubusercontent.com/12808495/55340961-f52f6c00-54cf-11e9-8506-09894ce1988e.png)

  Несмотря на то, что маржин был поставлен только заголовку, все его родители тоже съехали вниз:

  ![image](https://user-images.githubusercontent.com/12808495/55341005-0a0bff80-54d0-11e9-8ac2-1ca16dbc40a3.png)

<a name="5.2"></a>

- [5.2](#5.2) Родители игнорируют всех детей, у которых установлены `float: left` или `float: right`

<a name="5.3"></a>

- [5.3](#5.3) `z-index` свойство работает только для элементов, у которых значение position задано как `absolute`, `fixed` или `relative`.

<a name="5.4"></a>

- [5.4](#5.4) А еще на `z-index` может повлиять `opacity` Почитать про это можно [тут](https://habrahabr.ru/post/166435/).

<a name="5.5"></a>

- [5.5](#5.5) `height` в процентах не работает, если высота родителя формируется от контента.

  На `learn.javascript.ru` даже [статья](https://learn.javascript.ru/height-percent) есть.

<a name="5.6"></a>

- [5.6](#5.6) Все `:hover` эффекты проверять на мобильных устройствах внимательно в отдельном порядке, если проект поддерживает отображения на мобилах.

  В разных браузерах ховеры ведут себя по-разному и это надо согласовывать с дизайнерами отдельно — иногда, чтобы он заработал, надо, например, отдельный тап по элементу делать. Соответственно, чтобы сработал клик, надо тапнуть два раза, что тоже для некоторых элементов будет очень странно.

<a name="5.7"></a>

- [5.7](#5.7) Псевдоэлементы (`::after/before`) [не работают](https://stackoverflow.com/questions/14585070/css-after-pseudo-element-not-showing-up-on-img/14586588#14586588) с `self-closing tags` (`<img />`, `<input />`, etc.).

<a name="5.8"></a>

- [5.8](#5.8) Не использовать простой :hover для отображения новых элементов, которые нелегко достигнуть мышкой.

  Очень часто встречаются неудачные случаи с выпадающим меню, которое реализовано через псевдо-класс `:hover`, мало того, что это меню практически неработоспособно на мобильном устройстве, оно еще и доставляет немало головной боли пользователям десктопов. Решением в данном случае будет использование JavaScript.

  ![image](https://habrastorage.org/files/45f/aa7/1eb/45faa71eb7e74d3b8c39773cd181f298.gif)

<a name="5.9"></a>

- [5.9](#5.9) В ряде браузеров (Chrome, Opera, Edge, Firefox 62-, Safari 10-) теги форм, такие как `button`, `fieldset` и `legend`, не могут стать flex-контейнерами.

  Возможное решение — использовать элемент-обертку внутри тега (например, `span class="button__text"` внутри кнопки), и уже для него указать свойство `display: flex`:

  ```html
  <button class="button">
    <span class="button__text">...</span>
  </button>
  ```

  ```css
  .button__text {
    display: flex;
    ...;
  }
  ```

  Подробнее об этом и других багах, возникающих при работе с флексами, можно прочитать на [Flexbugs](https://github.com/philipwalton/flexbugs), перевод материала на русский [здесь](https://css-live.ru/articles/brauzernye-bagi-flexbox.html).

  Для решения проблем с флексами можно воспользоваться неплохим [postcss-плагином](https://github.com/luisrudge/postcss-flexbugs-fixes), который автоматически фиксит некоторые баги в написании стилей для флексов.
# JS

1. [Хорошие практики](#1)
2. [Именование переменных](#2)
3. [Именование функций](#3)
4. [Библиотеки](#4)
5. [JQuery](#5)
6. [React](#6)
7. [Производительность](#7)
8. [Архитектура](#8)
9. [Безопасность](#9)

<a name="1"></a>

## Хорошие практики

<a name="1.1"></a>

- [1.1](#1.1) Читаемость первостепенна

  Любое решение в первую очередь должно быть понятным и разбитым на логичные части, чтобы другие члены команды могли разобраться не только в назначении кода, но и в применяемых решениях без дополнительных оговорок.

<a name="1.2"></a>

- [1.2](#1.2) Все, что может быть написано на чистых html+css в рамках тех свойств, что дают заявленные браузеры - должно быть написано без применения JS.

  > _Это правило не должно противоречить предыдущему пункту_

  Это очень важное правило, так как:

  - Часто излишнее использование скриптов вводит других разработчиков в заблуждение, особенно, когда посреди работы скрипт внезапно меняет какие-либо свойства элемента.

  - Это уменьшает производительность веб-приложения.

  - Как правило код, написанный на html+css, гораздо проще изменять.

  Если реализация функционала на html+css возможна только с применением разных хаков, то тут уже стоит переходить на JS, чтобы поддерживаемость проекта не падала

<a name="1.3"></a>

- [1.3](#1.3) Избегать неявных критических зависимостей.

  Иногда на проекте могут возникнуть задачи, решая которые вы делаете систему уязвимой в плане падения, а не взлома. Пример из реальной жизни - подсчет суммы заказа на клиенте. Так как любым расчетам на клиенте нельзя доверять (ведь любой может простым HTTP запросом и другую цену послать), надо делать отдельный код на сервере, и при несовпадении значений заказ отклонять. Такого в идеале надо избегать по максимуму, но если это все-таки необходимо оставить в проекте, то надо сделать решение максимально безопасным (предусмотреть все случаи падений, зафиксировать их и обязательно уведомлять админов, если что-то пошло не так) и щедро осыпать комментариями и тестами.

  Вторым примером будет, когда вы в коде опираетесь на что-то из базы данных. Если в базе таких значений не будет, и ваша система упала - 99% что это ваша вина, даже если заполнение конкретно этого типа данных было священной обязанностью админов, которые прохалтурили.

<a name="1.4"></a>

- [1.4](#1.4) Знать и использовать стайлгайд от AirBnB.

  Сам он расположен [здесь](https://github.com/airbnb/javascript).

  Для него есть переводы, в том числе на русском, но читать надо оригинал, так как там описаны ES6 фичи. Все, что перечислено в гайде принять к исполнению, если это не перекрыто нашими правилами ниже.

<a name="1.5"></a>

- [1.5](#1.5) Использовать `eslint` или аналоги.

<a name="1.6"></a>

- [1.6](#1.6) Методы.

  **Именование**:

  Имя метода должно быть `self descriptive`(описывать само себя). Из названия должно быть понятно для чего нужен метод и что он делает. Не должно быть причин задумываться о его внутренней реализации.

  **Параметры**:

  Если в метод необходимо передать много параметров, объединяйте их в один объект. Например, у вас есть метод, который рисует прямоугольник принимая координаты точек, ширину, высоту, цвет, толщину рамок и другие параметры. В таком случае, проще будет передать один объект ‘options’. Это снимет с нас обязанность держать в голове все параметры, а также их порядок, и позволит удобно сделать многие свойства с дефолтными значениями.

  В случае, когда параметры передаются объектом, получать их значения предпочтительнее с помощью деструктуризации.

  Если параметр опциональный, необходимо ему задать значение по умолчанию.

  **Тело**:

  Соблюдать принцип Single Responsibility. Метод должен выполнять только одну задачу (например, метод `createReport`, который создает отчет и отправляет его на сервер необходимо разделить на два: `createReport` и `sendReport`).

  Метод должен быть компактным. Обычно, длина метода варьируется в пределах 10-40 строк. Это не значит что ваш метод обязательно должен должен быть в таких рамках, но если ваш метод занимает 200 строк, это повод задуматься о том, можно ли его разделить на несколько отдельных методов. Про компактность методов можно почитать у С. Макконела “Совершенный код” и Р. Мартина “Чистый код”. Так же [здесь](https://softwareengineering.stackexchange.com/questions/133404/what-is-the-ideal-length-of-a-method-for-you) Неплохое рассуждение о размерах метода.

<a name="1.7"></a>

- [1.7](#1.7) Делайте время жизни переменных как можно короче.

  Объявление переменной должно быть рядом с местом ее использования. Это дает более быстрое понимание того, что происходит в коде, плюс снижается вероятность неправильного использования переменной или ее перезапись.

  Более подробнее про время жизни переменной можно прочитать у С. Макконнелла в "Совершенном коде".

<a name="1.8"></a>

- [1.8](#1.8) Все кнопки сабмита должны быть внутри `<form>` вместе со всеми соответсвующими инпутами. Обработку завершения заполнения вешать на событие `submit` формы, а не клик по кнопке.

  Это очень важное правило для UX, которое часто упускается новичками. Еще раз: не вешайте обработку заполнения формы на событие `click` у кнопки, а вешайте на событие `submit` у формы. Как минимум, `submit` формы может быть вызван дополнительными путями - например, нажатие на enter у любого `input`, и, совершая ошибку, вы серьезно нарушаете UX всего сайта.

<a name="1.9"></a>

- [1.9](#1.9) Все проверки содержащие более одного условия должны быть вынесены.
  Выносить в отдельную архитектурную единицу - переменную или функцию.

  Плохо:

  ```javascript
    if ((this.allowUpdate) && ((user.isAdmin) || (user.role === item.owner)) {
      this.update(item.data);
    }
  ```

  Хорошо:

  ```javascript
    function isUpdateAllowedForUser(user, item) {
      return (this.allowUpdate) && ((user.isAdmin) || (user.role === item.owner);
    }
    //.. в нужном месте
    if (this.isUpdateAllowedForUser(user, item)) {
      this.update(item.data);
    }
  ```

  Тоже хорошо (пример ветвистого кода с кучей условий, где все именованно и раскидано, а поэтому понятно)

  ```javascript
    const isTodayRequested = day === 'today';
    const isTomorrowRequested = day === 'tomorrow';
    const isDepartTomorrow = departure.day() !== now.day() && unix(departure)  unix(now);
    const isDepartToday = departure.day() === now.day();
    const isRequestedDayIncorrect = (isDepartToday && !isTodayRequested) || (isDepartTomorrow && !isTomorrowRequested);
    const result = isRequestedDayIncorrect ? getPreviousDay(day) : day;
  ```

  Вынос условий и их раскидывание по разным функциям/переменным позволяет каждому условию дать человеческое имя и потом ваши коллеги могут удобно читать все логические взаимосвязи не в шифре, а в удобном виде, почти как художественный текст.

<a name="1.10"></a>

- [1.10](#1.10) Всегда избегать неявного приведения типов в JS.

  В нашем любимом языке можно складывать массивы со строками, объекты с числами и тд. Но делать этого, конечно же, не надо. Всегда явно преобразуйте переменные к одному типу при их сложении, вычитании, делении и умножении.

  Плохо:

  ```javascript
  const lifes = [true, false, false, true, true];
  aliveTotal = 0;
  for (let i = 0; i < lifes.length; i++) {
    aliveTotal += lifes[i]; // тут мы к числу прибавляем элемент массива, который boolean.
  }
  ```

  Самое ужасное, что код этот будет работать, но в нем все слишком уязвимо и его чтобы поддерживать, надо постоянно в голове держать, что там булины с числами складываются.

<a name="1.11"></a>

- [1.11](#1.11) Не изменять прототипы стандартных конструкторов (например, `String.prototype` или `Function.prototype`), до тех пор пока вопрос внимательно не изучен и этот трюк не согласован со старшим разработчиком.

<a name="1.12"></a>

- [1.12](#1.12) Конструктор класса должен быть максимально легковесным.

  Например, если требуется провести поиск по DOM-дереву для задания значений полям класса, то нужно вынести этот функционал в отдельный метод. Так же в случае если нужно задать обработчики для событий - в отдельный метод.

<a name="1.13"></a>

- [1.13](#1.13) Выносить обработчики событий в отдельные функции.

  Не стоит создавать анонимные функции прямо в том же месте, где идет привязка к событию.

  Плохо:

  ```javascript
  elem.addEventListener("click", function () {
    alert("Спасибо!");
  });
  ```

  Хорошо:

  ```javascript
  class Component {
    bindEventListeners() {
      topButton.addEventListener("click", this.handleStopButtonClick);
    }

    handleStopButtonClick() {
      // ...
    }
  }
  ```

<a name="1.14"></a>

- [1.14](#1.14) В обработчиках работать не с контекстом (this), а с аргументом объекта ивента, который был передан свыше.

  Не полагаться на this при работе с объектами событий, а использовать первый параметр коллбека event.
  Работать только с тем, что приходит из события. JS позволяет вносить дополнительные данные в event.
  То есть не использовать "this.value". Вместо этого получать данные через объект события "e.currentTarget.value".
  Плохо:

  ```javascript
  handleButtonClick() {
   const buttonWidth = $(this).width();
   // ...
  }
  ```

  Хорошо:

  ```javascript
  handleButtonClick(event) {
   const buttonWidth = $(event.currentTarget).width();
   // ...
  }
  ```

<a name="1.15"></a>

- [1.15](#1.15) Стараться по максимуму избегать циклов и использовать встроенные методы массивов.

  `.map`, `.filter` и тд обычно гораздо проще читаются, плюс функцию обработки одного элемента можно вынести и многократно использовать в разных местах.

<a name="1.16"></a>

- [1.16](#1.16) Не использовать литералы из бизнес-логики напрямую - надо создавать объект с константами.

  Если в бизнес-логике есть какой-то параметр, то надо создать где-то переменную, желательно в специальном месте для конфига, туда выносить все фиксированные значения, а в коде использовать их только по именам.

  Можно:

  ```javascript
   if (status === ordersModule.ACTIVE_STATUS) {...}
  ```

  Нельзя:

  ```javascript
   if (status === 'active') {...}
  ```

<a name="1.17"></a>

- [1.17](#1.17) Форматирование размещения импортов.

  Импорты объединяются в секции, секции разделяются переносом строки.
  Для фронта выделяются три секции (в таком порядке размещения):

  - Абсолютные импорты из node_modules;
  - Абсолютные импорты из src;
  - Относительные импорты, отсортированные в порядке убывания переходов на более верхний уровень в дереве пути (через ../).

    Например:

  ```javascript
  import * as React from "react";
  import block from "bem-cn";
  import { connect, Dispatch } from "react-redux";
  import { bindActionCreators } from "redux";
  import { arrayPush } from "redux-form";

  import { Modal } from "shared/view/elements";
  import { IPreset } from "shared/types/models";
  import { IAppReduxState } from "shared/types/app";
  import { actions as notificationActions } from "services/notification";
  import { selectors as configSelectors } from "services/config";

  import { actions, selectors } from "../../../redux";
  import { managePresetsFormEntry } from "../../../redux/reduxFormEntries";
  import { Presets } from "../../components/ManagePresets";
  import "./ManagePresets.scss";
  ```

  Также, для любого поддерева элемента пути не должно быть такого поддерева, импорты которого разделяются другим поддеревом такой же глубины.
  Например:
  Импорты поддерева `shared` (глубина 1) разделяются импортом поддерева services.

  ```javascript
  import { IModel } from "shared/types/models";
  import { i18nConnect } from "services/i18n";
  import { Component } from "shared/view/components";
  ```

  Правильно будет так:

  ```javascript
  import { IModel } from "shared/types/models";
  import { Component } from "shared/view/components";
  import { i18nConnect } from "services/i18n";
  ```

  Или в:

  ```javascript
  import { IAppReduxState } from "shared/types/app";
  import { Component } from "shared/view/components";
  import { IModel } from "shared/types/models";
  import { i18nConnect } from "services/i18n";
  ```

  импорты поддерева `shared/types` (глубина 2) разделяются импортом поддерева `shared/view`. Правильно будет так:

  ```javascript
  import { IAppReduxState } from "shared/types/app";
  import { IModel } from "shared/types/models";
  import { Component } from "shared/view/components";
  import { i18nConnect } from "services/i18n";
  ```

<a name="1.18"></a>

- [1.18](#1.18) Экспорты держать в конце файла.

  Плохо:

  ```javascript
  export class Foo {
    // ...
  }
  export class Bar {
    // ...
  }
  // finita la comedia
  ```

  Хорошо:

  ```javascript
  class Foo {
    // ...
  }
  class Bar {
    // ...
  }
  export { Foo, Bar };
  ```

<a name="1.19"></a>

- [1.19](#1.19) Если есть сомнения, поддерживает ли браузер какую-либо фичу - проверять непосредственно определена ли эта функция, а не сравнивать `user-agent` с названиями и версиями браузеров, которые по документации это поддерживают. А по хорошему вообще использовать [Modernizr](https://modernizr.com/).

<a name="1.20"></a>

- [1.20](#1.20) Избегать глобальных переменных.

  Почти в любом языке глобальные переменные - источник зла. В JavaScript это правило не исключение.

  Глобальные переменные делают работу программы непредсказуемой и усложняют изучение логики работы кода, плюс вызывает головокружение и гневные крики у опытных разработчиков при своем появлении.

  Чаще всего пользоваться глобальными переменными можно только потому что, так требуют олдскульные библиотеки, например Google Maps, которая создает глобальный объект google и карты можно кастомизировать только через него, и которая для колбека при своей инициации просит создать глобальную функцию, которую Google Maps потом сама вызовет.

  Можно на первых стадиях совсем простых проектов, где чуть-чуть анимаций на jquery использовать одну (и только одну) глобальную переменную, чтобы сохранять в нее модули и иметь возможность доступа к функциям из других js-файлов (по умолчанию сам js этого не поддерживает).

<a name="1.21"></a>

- [1.21](#1.21) К глобальным переменным обращаться только как к свойствам window.

  И создавать объекты только как свойства window, потому что объявление без var неочевидно - так же происходят переопределения переменных из замыкания и сложно отличить эти моменты.

  ```javascript
  // тут правило нарушено, создается глобальная переменная без window, и обращение к ней тоже без window:
  function test() {
    foo = "hello world"; // обратить внимание, что переменная создана без var, значит она глобальная
  }
  test();
  console.log(foo); // вывод 'hello world', обращение тоже без window
  ```

  ```javascript
  // тут следуют описанная глобальная переменная, как надо:
  function test() {
    window.foo = "hello world";
  }
  test();
  console.log(window.foo); // вывод 'hello world', обращение как к >свойству объекта window
  ```

<a name="1.22"></a>

- [1.22](#1.22) Используйте специальные обертки для логирования, а не сырой `console.log`.

  Вообще, логирование - это отдельное искусство, хорошие правила были описаны в [этой презентации](https://www.slideshare.net/nzakas/enterprise-javascript-error-handling-presentation/2-Whos_this_g_uy_P).

  У каждого лога должен быть префикс, который говорит из какого модуля вызван лог и в какое время он был вызван (таймстеймп);

  Разделять логирование как минимум на два уровня - `debug` и `production`, чтобы в production сборке не выводились логи для разработчиков;

  Все логи, которые ваша система производит, должны сохраняться в какую-либо единую переменную, чтобы в случае ошибок можно было сразу все отправить на сервер.

  <a name="1.23"></a>

- [1.23](#1.23) Старый код надо удалять, а не комментировать. Если он понадобится в дальнейшем, всегда можно будет посмотреть в истории коммитов.

  Это в первую очередь предназначено для ваших коллег - большие куски лишнего кода сбивают с толку, мешают поиску через `ctrl+F`, заставляют иногда отвлекаться на изучение кода. Так что лучше его скрыть в истории изменений.

<a name="1.24"></a>

- [1.24](#1.24) Все изменения в стилях, которые можно сделать через переключение классов у элемента, надо делать через добавление/удаление классов, а не простановку стилей у DOM-элементов. Так, например, можно переключать видимость элемента. Однако для непрерывно изменяющихся численных значений так сделать уже не получится, как например при изменении свойства `top` при скролле страницы, поэтому тут придётся все-таки проставлять напрямую у элемента значение в css-свойстве.\*\*;

  Это не только увеличит производительность (потому что за раз вы примените сразу все стили от нового класса), но и поможет потом переписать стили из css нормальным способом, потому что иначе стили будут инлайновые и из css их нельзя будет переопределить, кроме как через `!important`.

<a name="1.25"></a>

- [1.25](#1.25) Очень полезно понимать, как работают циклы перерисовки браузера и как можно проверить и увеличить производительность работы с DOM - здесь в статье перечислены [полезные источники](https://isobar-us.github.io/code-standards/#javascript_javascript_performance).

<a name="1.26"></a>

- [1.26](#1.26) Код должен быть без орфографических ошибок. Имена переменных, функций, комментарии должны быть написаны правильно.

  Обычно, чтобы избежать большинства ошибок, используют расширения для `IDE`, для `vscode` например есть хорошее расширение [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker).

<a name="1.27"></a>

- [1.27](#1.27) Вся работа со службами браузера (`navigator services`, `cookie`, `localStorage`) должна быть обернута в try/catch, т.к. это внешние по отношению к нашему коду службы, от которых не ясно, чего ждать. На спеки тут полагаться не стоит, т.к. есть и новые движки, которые имеют в том числе баги в своих сорцах.

  В сафари если включен режим инкогнито или если в браузере стоит блокировка `cookie`, то браузер будет райзить ошибку. Поэтому если ее не отловить, приложение посыпется :)

<a name="1.28"></a>

- [1.28](#1.28) Не расширять стандартные классы, такие как Array, Error, Map и другие, потому что вот [почему](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work)

<a name="2"></a>

## Именование переменных

<a name="2.1"></a>

- [2.1](#2.1) Именовать переменные по смыслу.

  Имя переменной должно полно и точно описывать сущность и ее предназначение.

  Имеется в виду не использовать в качестве имен date, result, array. Например, для текущей даты лучше использовать переменную today, а не date, для списка студентов лучше подойдет students а не array.

<a name="2.2"></a>

- [2.2](#2.2) Старайтесь не давать переменным слишком длинные имена.

  Как правило, чтобы раскрыть смысл переменной, достаточно около трех слов (10-15 символов). Переменные всегда используются в каком-то контексте, исходя из которого некоторые детали могут опускаться. Например, объект класса слайдера может содержать поле range, в котором содержится диапазон слайдера. Нет нужды называть это поле `sliderRange`, поскольку и так очевидно, что это относится к слайдеру. Длинные имена усложняют чтение кода и их следует использовать только тогда, когда более короткое имя неоднозначно и несет в себе слишком мало информации (учитывая контекст, о котором сказано выше) для понимания ее смысла.

<a name="2.3"></a>

- [2.3](#2.3) При именовании переменных использовать `camelCase`, так как это принято в JavaScript комьюнити.

  Если данные, которые приходят "со стороны" (например с бекенда), не в `camelCase` формате (`snake_case` или любой другой), имеет смысл нормализировать ключи для консистентности.

<a name="2.4"></a>

- [2.4](#2.4) Присваивайте булевым переменным имена, подразумевающие значение `true` или `false`.

  В основном мы юзаем префиксы в начале переменных: `is/are`, `has`, `with`. Порой название `boolean` переменной можно сформулировать как утверждение: `selectedColsWereChanged`, что позволит сделать код более читаемым и понятным.

  ```javascript
  if (selectedColsWereChanged) { // do something... }
  ```

  С другой стороны никто вас не ограничивает в использовании других конструкций английского языка: `will, should, etc`. которые позволят корректно выразить то, что вы хотите выразить в коде. Еще есть такой кейс: некоторые названия не нуждаются в дополнительной инфе, которая покажет что это `boolean` (либо по соображениям языка, либо так исторически сложилось): `pened, hidden, disabled, etc`. А вообще учите английский, чтобы грамотно выражать свои мысли и код :) Тогда вам не придется запоминать все эти штуки, и будет самим понятно почему так или иначе

<a name="2.5"></a>

- [2.5](#2.5) Использовать утвердительную форму булевых переменных.

  Имена, основанные на отрицании (такие как `notFound`, `notdone` и `notSuccessful`), при выполнении над переменной операции отрицания становятся куда менее понятны, например:

  ```javascript
  if (not notFound) {..}
  ```

  Подобные имена следует заменить на `found`, `done` и `processingComplete`, выполняя отрицание переменных в случае надобности. Так что для проверки нужного значения вы использовали бы выражение `found`, а не `not notFound`.

<a name="2.6"></a>

- [2.6](#2.6) Используйте объясняющие переменные.

  Плохо:

  ```javascript
  const address = "One Infinite Loop, Cupertino 95014";
  const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
  saveCityZipCode(
    address.match(cityZipCodeRegex)[1],
    address.match(cityZipCodeRegex)[2]
  );
  ```

  Хорошо:

  ```javascript
  const address = "One Infinite Loop, Cupertino 95014";
  const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
  const [_, city, zipCode] = address.match(cityZipCodeRegex) ?? [];
  saveCityZipCode(city, zipCode);
  ```

<a name="2.7"></a>

- [2.7](#2.7) Имя константы должно характеризовать абстрактную сущность, представляемую константой, а не конкретное значение.

  Например, нужна константа, отражающая количество рабочих дней:

  плохо: `FIVE`  
   хорошо: `WORK_DAYS.`

<a name="3"></a>

## Именование функций

<a name="3.1"></a>

- [3.1](#3.1) Все имена функций, за редкими исключениями (например, следование уже устоявшемуся соглашению в рамках какой-нибудь библиотеки), должны начинаться с глаголов.

<a name="3.2"></a>

- [3.2](#3.2) Функции высшего порядка, возвращающие функции, следует именовать по шаблону make + .\* + отглагольное существительное, где .\* — опциональный, синтаксически корректный набор слов уточняющий предназначение функции.

  Пример: `makeButtonClickHandler`.

<a name="3.3"></a>

- [3.3](#3.3) Обработчики событий.

  Под событиями понимаются не только DOM-события, но и какие-то абстрактные события, которые обрабатываются с помощью коллбэков, вроде `onClose` модального окна или `onLogin` формы логина):

  - Пропсы React-компоненты, относящиеся к обработке событий, должны именоваться по шаблону `onEventName`, где `EventName` — имя обрабатываемого события.

  - Обработчики событий для БЭМ-элементов, а также для компонент, вложенных в БЭМ-элементы, именуются по шаблону `handleElementNameEventName`, где `ElementName` - имя БЭМ-элемента.

    Примеры:

    ```JSX
    <button className="block__cancel-button" onClick={this.handleCancelButtonClick} />
    <div className="block__first-name-input">
      <Input onChange={this.handleFirstNameInputChange} />
    </div>
    ```

    Если компонента не вложена в БЭМ-элемент, то `ElementName` в данном случае стоит выбирать по смыслу, исходя из контекста\*\* (причем, поскольку БЭМ-элементы именуются по похожему принципу, то и БЭМ-элемент в данном случае назывался бы, скорее всего, так же):

    ```JSX
    <div className="block">
      <Button onClick={this.handleCancelButtonClick} />
      <Input onChange={this.handleFirstNameInputChange} />
    </div>
    ```

    Обоснование: именуя колбэки по такому шаблону, мы не будем тратить время на придумывание имени и всегда можем понять предназначение колбэка лишь посмотрев на его имя.

    **Примечание**: в случаях, когда тело обработчика используется где-то ещё, то его следует выносить в отдельную функцию: например, обработчик `handleButtonClick`, выводящий список итемов, может передаваться только в пропс `onClick` БЭМ-элемента "button"; если же требуется вывести список итемов еще в каких-то других случаях, то следует сделать следующим образом:

    ```JSX
    handleButtonClick() {
      showItems();
    }

    showItems() {
      // ...
    }
    ```

<a name="4"></a>

## Библиотеки

<a name="4.1"></a>

- [4.1](#4.1) Ни в коем случае никакой файл библиотеки не редактировать.

  Если есть небольшая полезная либа, у которой не хватает небольшой правки, то нужно сделать fork и отдельно в зависимостях указать путь до своей версии

<a name="4.2"></a>

- [4.2](#4.2) Изучайте best-practices для крупных библиотек, которые вы используете в проекте.

  Для Angular-а есть [руководство](https://github.com/mgechev/angularjs-style-guide/blob/master/README-ru-ru.md).  
   Для React-а есть [руководство](https://github.com/airbnb/javascript/tree/master/react) или [это](https://medium.com/lexical-labs-engineering/redux-best-practices-64d59775802e).

<a name="4.3"></a>

- [4.3](#4.3) Модули должны использоваться из node_modules.

  Если используются дополнительные модули, то в package.json должны быть прописаны пути до локальных модулей, которые вы установили.

<a name="4.4"></a>

- [4.4](#4.4) Выбор библиотеки.

  Когда для поставленной задачи можно использовать библиотеку, никогда не делать выбор за первой попавшейся в поисковике. Надо сначала проанализировать как минимум 3 самых популярных решения и для каждого:

  - Eсть ли у нее отдельный публичный репозиторий и где он находится.
  - Eсть ли у нее документация и описывает ли она использование библиотеки для нашей поставленной проблемы;
  - если доков нет или нет нормального описания, надо внимательно изучить код библиотеки и понять API, которое позволит решить проблему;
  - осмотреть открытые `issue` (хотя бы пробежать глазами по первым двум страницам) и изучить те, что могут повлиять на работу библиотеки в контексте нашего проекта;
  - принять решение о использовании библиотеки только совместно с другими равными по статусу или старшими фронтенд-разработчиками из команды;
  - Обратить внимание, сопровождается ли библиотека, или является заброшенной. Есть ли pull request'ы, и есть ли в них обсуждения. Принимаются ли pull request'ы;
  - Обратить внимание, протестирована ли библиотека. Если библиотека протестирована, то стоит уделить внимание тестам, которые были написаны для неё: какие use-cases покрываются в тестах, и решают ли эти use-cases проблемы, ради которых вы хотите её использовать. Так же стоит уделить внимание к качеству самих тестов, не являются ли они хрупкими к изменениям и т.д. Если к рассматриваемой библиотеке тестов нет, возможно, вам стоит поискать другую библиотеку.

<a name="5"></a>

## JQuery

> _или все библиотеки со схожим API, где мы ищем элементы по селекторам и манипулируем ими как с js-переменными, например:_
>
> ```javascript
> const $newMessage = $('<li class="js-message" />');
> const $messageList = $body.find("ul.js-messages");
> $messageList.append($newMessage);
> ```

<a name="5.1"></a>

- [5.1](#5.1) Все классы, которые используем для поиска по DOM-у должны начинаться с префикса `js-`.

  Например, есть кнопка, по клику открывающая попап - нам надо продублировать ее класс и добавить туда этот префикс:

  ```html
  <div class="open-popup-button js-open-popup-button"></div>
  ```

  В итоге в js-файлах мы используем только второй класс:

  ```javascript
  $('.js-open-popup-button').click(...);
  ```

  Это поможет избежать неожиданной поломки скриптов при смене верстки и наоборот.

<a name="5.2"></a>

- [5.2](#5.2) Конкатенировать селекторы, если с элементами будет проводиться одна и та же работа.

  ```javascript
  $("form p").addClass("valid");
  $("form li").addClass("valid");
  $("form span").addClass("valid");
  // - это лучше заменить на это:
  $("form p, form li, form span").addClass("valid");
  ```

<a name="5.3"></a>

- [5.3](#5.3) Все переменные, которые поддерживают jQuery API, должны начинаться со знака $.

  Например:

  ```javascript
  const $body = $("body");
  const $lists = $body.find("ul");
  ```

  А тут уже не jQuery API и переменные не должны начинаться с \$

  ```javascript
  // это нативной метод, который тоже возвращает нативной DOM-элемент
  const chatBox = document.getElementById("chat-box");

  // изъятие по индексу возвращает уже нативной DOM-элемент
  const firstList = $lists[0];
  ```

<a name="5.4"></a>

- [5.4](#5.4) Обработчики событий всегда именовать.

  ```javascript
  // Надо не просто делать
  $(window).scroll(...);
  // а
  $(window).on('scroll.myComponent', function (event) {...});
  ```

  Это позволит легко отсоединять обработчики, когда нужда в них отпадет.

<a name="5.5"></a>

- [5.5](#5.5) Поддерживать модульность.
  Так как идеология jquery не несет никаких знаний по тому, как организовывать более-менее сложные приложения (когда больше 3-х элементов на странице), то приходится все придумывать самим. Главные принципы, которым лучше следовать, чтобы код был чистый, а архитектура предсказуемой и понятной для других участников команды:

  <a name="5.5.1"></a>

  1. [5.5.1](#5.5.1) делить приложение на смысловые блоки. Все, что смотрится, как отдельный независимый элемент должно быть вынесено в отдельный блок. Весь js-код по нему должен быть в отдельном файле и строго отделен от остального приложения. У этого кода должен быть четкий и понятный интерфейс, который бы позволял внешнему миру общаться с блоком.

  <a name="5.5.2"></a>

  1. [5.5.2](#5.5.2) гарантировать независимость двух одинаковых блоков на одной странице друг от друга. То есть, если на странице два слайдера, то заранее на архитектурном уровне побеспокоиться, чтобы никакие события первого слайдера не влияли на второй.

  <a name="5.5.3"></a>

  1. [5.5.3](#5.5.3) Предыдущего условия (независимости однородных блоков) можно достичь, если js-код каждого блока обрамлять в класс, а затем для каждого встречного html-блока в верстке создавать по инстансу класса. В инстанс класса тогда можно сохранять сам DOM-элемент и потом только через него искать все вложенные элементы и только на них вешать обработчики.

  <a name="5.5.4"></a>

  1. [5.5.4](#5.5.4) Выше было требование, что все обработчики должны быть отименованы. Тут это принимает еще более строгий характер — имена обработчиков для разных инстансов одного и того же класса должны быть уникальными, чтобы \$(block).off(...) отключал события только для текущего инстанса блока, не для всех инстансов, а то неожиданно для разработчика сразу будут отключены обработчики события для всех слайдеров на странице.

  <a name="5.5.5"></a>

  1. [5.5.5](#5.5.5) Также классы позволяют сделать структуру всех блоков одинаковой и предсказуемой — зная, как устроен блок slider, уже можно предсказать, как устроены блоки calendar и dropdown. У всех у них будут методы инициализации и поиска вложенных DOM-элементов, у всех будет код, который навешивает события, у всех будет интерфейс по удалению инстанса и тд. Так что лучше сразу позаботиться об одинаковой структуре и все максимально стандартизировать.

<a name="6"></a>

## React

> _Читать и применять только если уже знакомы с React, в противном случае можно пока игнорировать_

<a name="6.1"></a>

- [6.1](#6.1) Все компоненты должны быть по умолчанию функциональными, то есть stateless ([что это такое?](https://reactjs.org/docs/components-and-props.html#stateless-functions)), и только при необходимости становиться `class-based` component.

<a name="6.2"></a>

- [6.2](#6.2) Метод `render()` должен быть чистым ([читаем доки](https://reactjs.org/docs/react-component.html#render)).

<a name="6.3"></a>

- [6.3](#6.3) Избегайте создания методов-рендеров в компонентах-классах (речь не о методе render, а о методах, которые вы можете написать помимо него, и которые тоже возвращают JSX).

  Так как эти методы возвращают куски JSX, которые не являются полноценными react-unit объектами, у вас могут возникнуть проблемы с сопровождением этих компонент в дальнейшем. И потом - с неправильно вынесенным jsx не удается работать как с полноценным react-unit, проблемы с рефами и отслеживаемостью в ДОМ.

  Если вы хотите вынести JSX — выносите его в stateless компоненту.  
   Например:

  ```javascript
  export class OrderStatus extends Component {
    renderStatusView(status) {
      // этот рендер должен быть вынесен в отдельную компоненту
      if (status === "succeed") {
        return <span>Done!</span>;
      }
      return <span>Active...</span>;
    }

    render() {
      return (
        <div>
          Order status: {this.renderStatusView(this.props.status)}// Здесь
          должна использоваться компонента, а не метод
        </div>
      );
    }
  }
  ```

<a name="6.4"></a>

- [6.4](#6.4) Метод `render()` и все методы, возвращающие куски DOM-a, должны располагаться в конце компоненты, сам метод `render` самым последним из публичных.

<a name="6.5"></a>

- [6.5](#6.5) Принципы работы с `action creators (redux)`.

  - Следует избегать лишнего `getState` обращения в `action creator`, кроме специфических случаев (например, когда вьюха никак не может получить достаточное количество данных). Данные следует отправлять в `action creator` явно аргументами, чтобы явно указать, с какими данными функция работает и что ей необходимо для корректной работы.

  - Декомпозиция сложного экшна (состоящего из нескольких структурных, алгоритмических экшнов) должна проводиться в присутствии старшего разработчика. то есть если напрашивается множественный `dispatch` в одном `action creatore`, следует обсудить этот момент со старшим разработчиком, т.к. бывают случаи, когда этого можно избежать, а бывают - когда не удается

  - Следует вызывать action creators только в контейнерах, в ответ на более низкоуровневые действия глупых компонентов: к примеру `registerUser action` следует вызывать в ответ на `OnSubmit` событие компонента формы регистрации.

<a name="7"></a>

## Производительность

<a name="7.1"></a>

- [7.1](#7.1) В проектах на jquery или чем-либо, где поиск DOM-элементов идет по селекторам - надо кэшировать все найденные элементы.

  ```javascript
  $foodItem = $("#shopping-list li");

  $foodItem.click(function () {
    // do something...
  });
  ```

<a name="7.2"></a>

- [7.2](#7.2) Все операции с DOM-ом лучше сначала проводить на виртуальных элементах, а потом сразу целиком вставлять в документ страницы.

  здесь в цикле в DOM внедряется каждый элемент массива один за одни, в итоге имеем кучу циклов перерисовки:

  ```javascript
  for (let i=0; i < items.length; i++) {
      const item = document.createElement("li");
      item.appendChild(document.createTextNode("Option " + i);
      list.appendChild(item);
  }
  ```

  здесь мы в цикле вносим элемент в виртуальный элемент, а затем уже целиком за раз это внедряем в реальный DOM и получаем один цикл перерисовки:

  ```javascript
  const fragment = document.createDocumentFragment();
  for (let i=0; i < items.length; i++) {
      const item = document.createElement('li');
      item.appendChild(document.createTextNode('Option ' + i);
      fragment.appendChild(item);
  }
  list.appendChild(fragment);
  ```

<a name="7.3"></a>

- [7.3](#7.3) Избегать сложных селекторов.

  В зависимости от типа и сложности css-селектора зависит производительность рендеринга и анимации сайта. Например использование в `transition` селектора по атрибуту (например `input[type="text"] { transform: translateX(50%)` } теоретически может замедлить саму анимацию. Те же правила экстраполируются на всю страницу. Чем сложнее css-селекторы (много вложенности и нетривиальных селекторов с необходимостью часто и много считать приоритеты), тем сложнее браузеру рендерить страницу, т.к. приходится применять стили согласованно между друг другом и анализировать DOM-дерево, что, конечно, не самая простая задача с точки зрения производительности сама по себе.

<a name="7.4"></a>

- [7.4](#7.4) Все js-ки подключаем внизу страницы перед закрывающимся тегом `<body>`.

<a name="7.5"></a>

- [7.5](#7.5) Полезные материалы:

  - [Perf.Rocks](https://perf.rocks/)
  - [calendar](https://calendar.perfplanet.com/2014/)
  - [PageSpeed Insights Rules](https://developers.google.com/speed/docs/insights/rules)
  - [avascriptrocks](http://javascriptrocks.com/)

<a name="8"></a>

## Архитектура

<a name="8.1"></a>

- [8.1](#8.1) Модульность - наше все!

  Обязательно дробить приложение на разные модули, даже если сайт - просто статичный контент с несколькими обработчиками событий, которые вешаются через jquery.

  Для импорта модулей друг в друга использовать webpack, если проект совсем простой, можно обойтись созданием одного (!) глобального объекта и у него свойствами сохранять разные модули.

  Для каждого модуля - только один файл. Без использования webpack и других сборщиков сами заботьтесь о том, чтобы не загрязнять глобальную область видимости (оборачивать все содержимое каждого файла в самовызывающуюся функцию).

  В рамках одного модуля описывать только схожий функционал, который объединен смыслом. Это называется [связность](<https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>). Обратная сторона медали - [зацепление](<https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>), когда модули друг от друга сильно зависят - этого как раз надо избегать. То есть общий принцип - модули надо разбить так, чтобы внутри каждого модуля была максимальная схожесть области работы, а между модулями было максимальное различие. Например, в статистике сегмантация выполняется по таким же принципам, все группы должны состоять из максимально похожих элементов и при этом максимально отличаться друг от друга :).

<a name="8.2"></a>

- [8.2](#8.2) В рамках модуля четко делить на слои и не мешать логику работы с DOM и работу с данными (например, ajax-запросы).

  Вообще всю работу с самими данными максимально отделять от работы с DOM и обработке событий пользователя (клики, сабмиты и тд).

  Желательно для каждого приложения более менее формализовать структуру модуля, описать ее в конкретном виде для всех проектов невозможно, так как что-то пишется на `React`, что-то на `React+Redux`, а что-то на простом `jquery`. Для последнего этот пункт наиболее важен, но при этом наиболее неопределен.

<a name="8.3"></a>

- [8.3](#8.3) Избегать мутаций одной переменной сразу в нескольких функциях.

  Пример плохого кода:

  ```javascript
  const box = {};

  function addBall(box) {
    box.ball = { radius: 2 };
  }

  function addFood(box) {
    box.food = { carrot: 4 };
  }

  function addShoes(box) {
    box.shoes = { sneakers: 2 };
  }

  addBall(box);
  addFood(box);
  addShoes(box);
  ```

  Из-за таких действий область использования переменной становится слишком большой и тяжело понять, какая именно функция и когда изменила переменную. Когда произойдет ошибка в 10-ой функции, будет непонятно почему box содержит 5 пар кроссовок и 15 морковок.

  Используйте чистые функции, пересоздавайте объекты, а не мутируйте их, а еще лучше формализуйте все возможности изменить ваш объект, как это делает `Redux` для переменной состояния приложения.

<a name="8.4"></a>

- [8.4](#8.4) В js нет публичных и частных свойств, поэтому частные методы просто делать с префиксами `"_"` (нижнее подчеркивание).

  ```javascript
  class Person {
    constructor(name) {
      this.name = name;
    }

    public() {
      console.log("Call me from the outer modules");
    }

    _private() {
      console.log(
        "Call me only from the class Person methods, for example from public"
      );
    }
  }
  ```

<a name="8.5"></a>

- [8.5](#8.5) При написании класса все публичные методы объявляйте первыми, причем самым первым должен идти конструктор, все приватные методы группируйте по смыслу внизу класса

<a name="9"></a>

## Безопасность

- [Browser Security Handbook from Google](https://code.google.com/archive/p/browsersec/wikis/Main.wiki).
- [HTML5 Security Cheatsheet](https://html5sec.org/#javascript).
- [Web Security Basics](https://github.com/vasanthk/web-security-basics).
  
  
